### 26. 객체 생성 방식 — 리터럴과 생성자 함수 차이

#### 객체 리터럴

- {}로 즉시 객체 생성.

- 가장 간단하고 직관적인 방식.

- 매번 새로운 객체가 생성됨.

#### 생성자 함수

- function User() { ... } 형태로 정의.

- new 키워드로 인스턴스 생성.

- 인스턴스들은 프로토타입을 공유하여 메서드 중복을 줄인다.

#### 차이 핵심

- 리터럴: 객체 1개만 만들 때 단순함.

- 생성자: 동일 구조/동일 메서드를 가진 객체 여러 개 만들 때 효율적.

### 27. 프로토타입 기초 — 객체가 내부적으로 연결되는 구조

#### 핵심 개념

- 모든 객체는 [[Prototype]](숨겨진 링크) 을 갖는다.

- JS는 클래스 기반이 아니라 프로토타입 기반 상속을 사용한다.

- obj.**proto** 는 실제 내부 링크를 보여주는 디버깅용 접근자.

#### 목적

- 객체끼리 메서드/속성을 공유하기 위한 구조.

- 메서드를 개별 객체가 들고 있지 않고 프로토타입에 공유 저장.

### 28. 생성자 함수와 프로토타입 — 인스턴스가 메서드를 공유하는 원리

#### 구조

- 생성자 함수: User

- 생성자 함수의 프로토타입 객체: User.prototype

- 인스턴스: new User()

#### 동작

1. 인스턴스는 자신의 프로퍼티만 갖고 있고

2. 메서드는 User.prototype 에 저장

3. 호출 시 프로토타입 체인을 통해 메서드를 찾는다.

#### 장점

- 메서드 중복 메모리 낭비 제거

- 객체 간 공통 행동 정의 가능

### 29. 프로토타입 상속 — 상속 구조와 체인의 동작 방식

#### 프로토타입 체인

- 특정 프로퍼티가 객체에 없으면
  → 프로토타입에서 탐색
  → 최종적으로 Object.prototype 까지 올라감.

#### 상속 방식

- A.prototype = Object.create(B.prototype)

- 객체 간 기능을 손쉽게 상속 가능.

#### 장점

- 코드 재사용성↑

- 필요한 기능만 계층적으로 확장 가능

#### 주의점

- 체인이 깊을수록 탐색 비용 증가

- 무분별한 상속 구조는 디버깅 어려움

### 30. 프로토타입 정리

#### 핵심 요약

- 객체는 [[Prototype]] 링크를 통해 상속 구조를 형성한다.

- 생성자 함수 + 프로토타입 조합으로 메모리 효율적.

- 프로토타입 체인은 JS의 상속·공유·확장 구조의 기반.
