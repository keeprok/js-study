## 5. 스코프의 정의와 종류 — 변수가 어디까지 유효한가?
1) 스코프란?

스코프(Scope)는 변수와 함수가 유효하게 접근될 수 있는 범위를 의미한다.
JavaScript는 렉시컬 스코프(정적 스코프) 기반 언어로,
“함수가 어디에서 선언되었는지”에 따라 스코프가 결정된다.

2) 스코프의 종류
| 스코프                        | 설명                               |
| -------------------------- | -------------------------------- |
| **전역 스코프(Global Scope)**   | 코드 어디서든 접근 가능                    |
| **함수 스코프(Function Scope)** | 함수 내부에서만 접근 가능 (`var`)           |
| **블록 스코프(Block Scope)**    | `{}` 내에서만 접근 가능 (`let`, `const`) |

3) var vs let/const
| 키워드         | 스코프    | 비고                         |
| ----------- | ------ | -------------------------- |
| var         | 함수 스코프 | 호이스팅 시 undefined로 초기화      |
| let / const | 블록 스코프 | TDZ(Temporal Dead Zone) 존재 |

## 6. 스코프 체인 — 중첩된 스코프의 탐색 규칙
1) 스코프 체인이란

변수를 찾을 때 현재 스코프 → 상위 스코프 → 전역 스코프 순으로 탐색하게 되는 구조.

2) 왜 필요한가?

중첩 함수의 구조에서 변수를 올바르게 찾기 위함.
이를 위한 JS 내부 구조를 렉시컬 환경 이라고 한다.

## 7. 렉시컬 스코프 — 선언 위치 기준
핵심 개념

- JS는 실행 위치가 아니라 선언 위치가 스코프를 결정한다.

- 이는 동적 스코프 언어(Python 일부 기능 등) 와의 차이점.

예시)

```js
let x = 1;

function foo() {
  console.log(x);
}

function bar() {
  let x = 10;
  foo(); // 1
}

bar();

```

## 8. 실행 컨텍스트 — 코드 실행을 위한 환경 묶음
1) 실행 컨텍스트란?

코드가 실행되기 위한 모든 정보(스코프, 변수, this 등)를 담고 있는 객체.

2) 실행 컨텍스트 생성 과정

1. 전역 실행 컨텍스트 생성

2. 함수 호출 시 새로운 실행 컨텍스트 생성

3. 컨텍스트 스택(콜 스택)에 push

4. 실행 종료 후 pop

3) 실행 컨텍스트 구조

| 프로퍼티                    | 설명                        |
| ----------------------- | ------------------------- |
| **VariableEnvironment** | 선언 초기 정보 저장               |
| **LexicalEnvironment**  | let/const, 환경 레코드, 스코프 정보 |
| **ThisBinding**         | this 값 저장                 |

## 10. 호이스팅 — 선언이 끌어올려지는 이유와 시점
1) 호이스팅이란

변수와 함수 선언이 해당 스코프의 최상단으로 끌어올려진 것처럼 보이는 현상.

2) 실제 동작

- JS 엔진은 선언 단계 만 끌어올림

- var → undefined로 초기화됨

- let, const → 초기화되지 않아서 TDZ에 존재

- 함수 선언문 → 전체 함수가 호이스팅됨

예시 )
```js
console.log(a); // undefined
var a = 10;

console.log(b); // ReferenceError
let b = 20;
```

## 11. this 키워드 — 실행 방식에 따라 달라지는 실행 주체
#### this 결정 규칙

1. 일반 호출 → 전역(브라우저: window, Node: global)

2. 메서드 호출 → 객체

3. 생성자 호출 (new) → 새로 생성된 인스턴스

4. call/apply/bind → 명시적 지정

5. 화살표 함수 → 상위 스코프의 this를 가져옴 (렉시컬 this)

## 12. this의 명시적 바인딩 — call, apply, bind

| 메서드         | 특징                           |
| ----------- | ---------------------------- |
| **call()**  | 함수 호출 + this 설정 + 인자를 쉼표로 전달 |
| **apply()** | call과 동일, 인자를 배열로 전달         |
| **bind()**  | this를 영구적으로 묶은 새 함수 반환       |

예시)
```js
function hi() { console.log(this.name); }

const user = { name: 'Riel' };

hi.call(user);

```

## 13. strict mode — 안전한 실행을 위한 엄격 모드
1) 특징

- 암묵적 전역변수 생성 금지

- this가 undefined로 설정됨 (함수 단독 호출 시)

- 오류를 빨리 발견할 수 있음

예시)
```js
'use strict';
x = 10; // ReferenceError

```

## 14. 자바스크립트 런타임 — 브라우저와 Node.js

JS가 돌아가는 환경

- 브라우저 → Web API 제공 (setTimeout, fetch 등)

- Node.js → OS/파일시스템 등 제공